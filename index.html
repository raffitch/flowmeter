<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Flow-Sensor Calibration</title>
<style>
  body   {font-family:sans-serif;max-width:520px;margin:2rem auto}
  h1     {font-size:1.4rem;margin-bottom:.6rem}
  .big   {font-size:2.2rem;font-weight:700;margin:.4rem 0}
  button {padding:.6rem 1.2rem;font-size:1rem;margin:.25rem}
  #result{margin-top:1rem;font-size:1.2rem;color:#0a7900}
  #status{margin:.8rem 0;font-size:.95rem;color:#555}
  #chart {width:100%;height:260px;margin-top:1rem;border:1px solid #ccc}
</style>
<script src="https://cdn.plot.ly/plotly-2.31.0.min.js"></script>
</head>
<body>
<h1>Flow-sensor calibration</h1>

<div id="status">Connectingâ€¦</div>

<div>
  Sensor <select id="sensor">
    <option value="flow">Flowmeter</option>
    <option value="scale">Scale</option>
  </select>
</div>

<div id="pulsesBox">
  <div>Pulses counted</div>
  <div id="pulses" class="big">0</div>
</div>

<div id="weightBox" style="display:none">
  <div>Weight (g)</div>
  <div id="weight" class="big">0</div>
</div>

<div>Elapsed time</div>
<div id="elapsed" class="big">0.0 s</div>

<div id="avgBox">
  <div>Average pulses / s</div>
  <div id="avg" class="big">0</div>
</div>

<div>Regulator version <input id="reg" type="text" style="width:6em"></div>
<div>Supply pressure (MPa) <input id="press" type="text" style="width:6em"></div>
<div id="limitPulse">Stop after pulses <input id="targetP" type="number" min="1" step="1" style="width:6em"></div>
<div id="limitWeight" style="display:none">Stop at weight (g) <input id="targetW" type="number" min="1" step="1" style="width:6em"></div>
<div>Stop after seconds <input id="targetS" type="number" min="1" step="1" style="width:6em"></div>
<div><label><input id="autoStop" type="checkbox" checked> auto-stop when value stops changing</label></div>

<button id="start" disabled>Start</button>
<button id="stop" disabled>Stop</button>
<button id="reset" disabled>Reset pulses</button>
<button id="resetAll" disabled>Reset all</button>
<button id="saveCsv" disabled>Save CSV</button>
<button id="savePng" disabled>Save PNG</button>

<div id="chart"></div>

<div id="result"></div>
<ul id="log"></ul>

<script>
(() => {
  const MEDIAN_WINDOW = 5;
  const MA_WINDOW = 5;
  const EMA_ALPHA = 0.5;
  const VOLUME_L = 1;

  const $ = id => document.getElementById(id);
  const statusEl=$('status'), sensorEl=$('sensor'),
        pulsesEl=$('pulses'), weightEl=$('weight'), elapsedEl=$('elapsed'),
        avgEl=$('avg'), regEl=$('reg'), pressEl=$('press'),
        targetPEl=$('targetP'), targetWEl=$('targetW'), targetSEl=$('targetS'),
        startBtn=$('start'), stopBtn=$('stop'), resetBtn=$('reset'), resetAllBtn=$('resetAll'),
        saveCsvBtn=$('saveCsv'), savePngBtn=$('savePng'),
        pulsesBox=$('pulsesBox'), weightBox=$('weightBox'), avgBox=$('avgBox'),
        limitPulse=$('limitPulse'), limitWeight=$('limitWeight'),
        autoStopEl=$('autoStop'), chartDiv=$('chart'), logEl=$('log');

  let sensor = 'flow';
  function updateSensor() {
    sensor = sensorEl.value;
    const isFlow = sensor === 'flow';
    pulsesBox.style.display = isFlow ? '' : 'none';
    avgBox.style.display    = isFlow ? '' : 'none';
    limitPulse.style.display= isFlow ? '' : 'none';
    weightBox.style.display = isFlow ? 'none' : '';
    limitWeight.style.display = isFlow ? 'none' : '';
    Plotly.relayout(chartDiv,{yaxis:{title:isFlow?'pulses / s':'grams',rangemode:'tozero'}});
  }
  sensorEl.onchange = updateSensor;
  updateSensor();

  Plotly.newPlot(chartDiv, [], {
    xaxis:{title:'time (s)', range:[0,90]},
    yaxis:{title:'pulses / s', rangemode:'tozero'},
    margin:{l:40,r:10,b:40,t:10}
  }, {responsive:true, displaylogo:false, scrollZoom:true});

  let armed=false, running=false, startPend=false;
  let lastPulse=0, lastWeight=0, lastMillis=0;
  let t0=0, lastChange=0;
  let filt=null, ema=null;
  const rawBuf=[], avgBuf=[];
  const runs=[];
  let current=null;
  let xMax=0;

  function softReset(){
    pulsesEl.textContent='0';
    weightEl.textContent='0';
    elapsedEl.textContent='0.0 s';
    avgEl.textContent='0';
    ema=filt=null; rawBuf.length=0; avgBuf.length=0;
    armed=running=startPend=false;
    lastPulse=0; lastWeight=0; lastMillis=0;
    if(current && !current.end) current.end=new Date();
    current=null;
  }
  function hardReset(){
    softReset();
    runs.length=0;
    Plotly.react(chartDiv, [], {xaxis:{title:'time (s)',range:[0,90]},yaxis:{title:'pulses / s',rangemode:'tozero'},margin:{l:40,r:10,b:40,t:10}}, {responsive:true, displaylogo:false, scrollZoom:true});
    logEl.innerHTML='';
    xMax=0;
  }

  const ws = new WebSocket('ws://localhost:8765');
  ws.onopen = () => { statusEl.textContent='ðŸŸ¢ WebSocket open'; startBtn.disabled=resetBtn.disabled=resetAllBtn.disabled=false; saveCsvBtn.disabled=savePngBtn.disabled=false; };
  ws.onerror= () => { statusEl.textContent='ðŸ”´ WebSocket error'; };

  ws.onmessage = ev => {
    const d = JSON.parse(ev.data);
    const now = performance.now();

    if(d.type==='live'){
      pulsesEl.textContent=d.pulses;
      if(d.weight!=null) weightEl.textContent=d.weight.toFixed(1);

      if(sensor==='scale'){
        if(armed && !running && d.weight!==lastWeight){ running=true; startPend=false; t0=now; lastChange=now; newRun(); }
        if(running && current){
          const t=(now-t0)/1000;
          addPoint(t,d.weight);
        }
        if(d.weight!==lastWeight) lastChange=now;
      }else{
        if(armed && !running && d.pulses!==lastPulse){ running=true; startPend=false; t0=now; lastChange=now; filt=null; newRun(); }
        const dt= lastMillis? (d.millis-lastMillis)/1000 : 0;
        if(dt>0 && d.pulses!==lastPulse){
          const raw=(d.pulses-lastPulse)/dt;
          rawBuf.push(raw); if(rawBuf.length>MEDIAN_WINDOW) rawBuf.shift();
          const mid=[...rawBuf].sort((a,b)=>a-b)[Math.floor(rawBuf.length/2)];
          avgBuf.push(mid); if(avgBuf.length>MA_WINDOW) avgBuf.shift();
          const m=avgBuf.reduce((a,b)=>a+b,0)/avgBuf.length;
          ema=ema===null?m:EMA_ALPHA*m+(1-EMA_ALPHA)*ema;
          filt=ema;
          avgEl.textContent=filt.toFixed(1);
          if(running && current){
            const t=(now-t0)/1000;
            addPoint(t,filt);
          }
        }
        if(d.pulses!==lastPulse) lastChange=now;
      }

      if(autoStopEl.checked && running && now-lastChange>1000){
        ws.send('stop'); running=false; startPend=false; armed=false;
      }
      if(running) elapsedEl.textContent=((now-t0)/1000).toFixed(1)+' s';

      lastPulse=d.pulses; lastWeight=d.weight; lastMillis=d.millis;
    }

    if(d.type==='status'){ if(d.msg==='counter-reset'){ resultEl.textContent='Counter reset'; } }

    if(d.type==='ack' && d.status==='started'){ softReset(); armed=true; startPend=true; }

    if(d.type==='cal'){
      armed=running=false; startPend=false; elapsedEl.textContent=d.elapsed.toFixed(1)+' s';
      if(current){ Object.assign(current,{end:new Date(),delta:d.delta,elapsed:d.elapsed,pps:d.pps,rate:d.rate,sensor:d.sensor}); addLog(current); current=null; }
      if(d.sensor==='scale'){ resultEl.textContent=d.rate+' g/s'; }
      else { resultEl.textContent=d.pps+' pps'; }
    }
  };

  function addPoint(t,y){
    current.trace.x.push(t); current.trace.y.push(y);
    if(t>xMax){ xMax=t; Plotly.relayout(chartDiv,{"xaxis.range":[0,Math.max(90,xMax)]}); }
    Plotly.extendTraces(chartDiv,{x:[[t]],y:[[y]]},[current.idx]);
  }
  function newRun(){
    const hue=(runs.length*60)%360;
    const name=`Run ${runs.length+1}: ${regEl.value||'n/a'} â€” ${pressEl.value||'n/a'} MPa`;
    const trace={x:[],y:[],mode:'lines',line:{color:`hsl(${hue},70%,40%)`},name:name,hovertemplate:sensor==='scale'?`${name}<br>%{y:.1f} g at %{x:.1f}s<extra></extra>`:`${name}<br>%{y:.1f} pps at %{x:.1f}s<extra></extra>`};
    Plotly.addTraces(chartDiv, trace);
    current={idx:chartDiv.data.length-1, trace:trace, sensor:sensor, volume:VOLUME_L, regulator:regEl.value, pressure:pressEl.value, start:new Date(), end:null};
    runs.push(current);
  }
  function addLog(r){
    const li=document.createElement('li');
    const dur=(r.elapsed||0).toFixed(1);
    if(r.sensor==='scale'){ li.textContent=`${r.start.toLocaleString()} â€” ${dur}s, ${(r.rate||0).toFixed(1)} g/s (${r.delta.toFixed(1)} g)`; }
    else { li.textContent=`${r.start.toLocaleString()} â€” ${dur}s, ${(r.pps||0).toFixed(1)} pps (${r.delta} pulses)`; }
    logEl.appendChild(li);
  }

  startBtn.onclick = () => {
    ws.send(JSON.stringify({cmd:'start',volume:VOLUME_L,sensor:sensor,pulses:sensor==='flow'&&targetPEl.value?Number(targetPEl.value):undefined,weight:sensor==='scale'&&targetWEl.value?Number(targetWEl.value):undefined,seconds:targetSEl.value?Number(targetSEl.value):undefined}));
  };
  stopBtn.onclick = () => { ws.send('stop'); running=false; startPend=false; armed=false; };
  resetBtn.onclick = () => { ws.send('reset'); softReset(); };
  resetAllBtn.onclick = () => { ws.send('reset'); hardReset(); };
  saveCsvBtn.onclick = () => { downloadCsv(); };
  savePngBtn.onclick = () => { Plotly.toImage(chartDiv,{format:'png'}).then(url=>{Object.assign(document.createElement('a'),{href:url,download:'flow_chart.png'}).click();}); };

  function downloadCsv(){
    if(!runs.length){ alert('No data yet'); return; }
    let csv='';
    runs.forEach((r,i)=>{
      csv+=`# run=${i+1}\n`;
      if(r.start) csv+=`# start=${r.start.toISOString()}\n`;
      if(r.end) csv+=`# end=${r.end.toISOString()}\n`;
      csv+=`# volume_L=${r.volume}\n`;
      csv+=`# regulator_version=${r.regulator}\n`;
      csv+=`# supply_pressure=${r.pressure}\n`;
      csv+= r.sensor==='scale' ? 'time_s,grams\n' : 'time_s,pps_filtered\n';
      r.trace.x.forEach((x,i)=>{ csv+=`${x},${r.trace.y[i]}\n`; });
      csv+='\n';
    });
    const url=URL.createObjectURL(new Blob([csv],{type:'text/csv'}));
    Object.assign(document.createElement('a'),{href:url,download:'flow_curves.csv'}).click();
    URL.revokeObjectURL(url);
  }
})();
</script>
</body>
</html>
