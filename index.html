<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Flow-Sensor Calibration</title>
<style>
  body   {font-family:sans-serif;max-width:520px;margin:2rem auto}
  h1     {font-size:1.4rem;margin-bottom:.6rem}
  .big   {font-size:2.2rem;font-weight:700;margin:.4rem 0}
  button {padding:.6rem 1.2rem;font-size:1rem;margin:.25rem}
  #result{margin-top:1rem;font-size:1.2rem;color:#0a7900}
  #status{margin:.8rem 0;font-size:.95rem;color:#555}
  #flowChart {width:100%;height:260px;margin-top:1rem;border:1px solid #ccc}
</style>

<!-- Plotly for interactive charts -->
<script src="https://cdn.plot.ly/plotly-2.31.0.min.js"></script>
</head>
<body>
<h1>Flow-sensor calibration</h1>

<div id="status">Connecting‚Ä¶</div>

<div>Pulses counted</div>
<div id="pulse"  class="big">0</div>

<div>Elapsed time</div>
<div id="timer" class="big">0.0&nbsp;s</div>

<div>Average pulses / s</div>
<div id="pps" class="big">0</div>

<div>Regulator version <input id="regVersion" type="text" style="width:6em"></div>
<div>Supply pressure (MPa) <input id="supplyPressure" type="text" style="width:6em"></div>
<div>Stop after pulses <input id="targetCounts" type="number" min="1" step="1" style="width:6em"></div>
<div>Stop after seconds <input id="targetSeconds" type="number" min="1" step="1" style="width:6em"></div>
<div><label><input id="autoStop" type="checkbox" checked> auto-stop when pulses stop</label></div>

<button id="start"  disabled>Start</button>
<button id="stop"   disabled>Stop</button>
<button id="reset"  disabled>Reset pulses</button>
<button id="resetAll" disabled>Reset all</button>
<button id="saveCsv" disabled>Save CSV</button>
<button id="savePng" disabled>Save PNG</button>

<div id="flowChart"></div>

<div id="result"></div>
<ul id="logList"></ul>

<script>
(() => {
  /* --- Filtering windows (samples) --- */
  const MEDIAN_WINDOW = 5;  // removes spikes before averaging
  const MA_WINDOW = 5;      // final smoothing (~1‚Äâs with 200‚Äâms frames)
  const EMA_ALPHA = 0.5;    // exponential smoothing factor
  const VOLUME_L = 1;       // fixed calibration volume

  /* --- DOM refs --- */
  const $ = id => document.getElementById(id);
  const statusEl=$('status'), pulseEl=$('pulse'), timerEl=$('timer'),
        ppsEl=$('pps'),
        resultEl=$('result'), startBtn=$('start'), stopBtn=$('stop'),
        resetBtn=$('reset'), resetAllBtn=$('resetAll'),
        saveCsvBtn=$('saveCsv'), savePngBtn=$('savePng'),
        regVerEl=$('regVersion'), pressureInputEl=$('supplyPressure'),
        targetCountsEl=$('targetCounts'), targetSecondsEl=$('targetSeconds'),
        autoStopEl=$('autoStop'),
        chartEl=$('flowChart'), logList=$('logList');

  /* --- Plotly chart (interactive zoom & hover) --- */
  const WINDOW_SEC = 90;        // adjust to change graph width
  Plotly.newPlot(chartEl, [], {
    xaxis:{title:'time (s)', range:[0, WINDOW_SEC]},
    yaxis:{title:'pulses / s', rangemode:'tozero'},
    margin:{l:40,r:10,b:40,t:10}
  }, {responsive:true, displaylogo:false, scrollZoom:true});

  /* --- run-time state --- */
  let armed=false,running=false,startPending=false;
  let t0=0;
  let lastPulse=0,lastTime=performance.now(),lastMillis=0,lastChange=performance.now();
  let filtPps = null;            // holds the filtered value
  let emaPps = null;             // exponential smoothed value
  const rawBuf = [];             // median filter buffer
  const ppsBuf = [];             // moving-average buffer
  const runs=[];                 // store all runs
  let currentRun=null;           // {traceIndex, trace, volume, regulator, pressure, start,end}
  let globalMax=0;
  const NO_FLOW_MS = 1000;    // auto-stop after 1s without pulses

  /* --- helpers: downloads --- */
  function downloadCsv(){
    if(!runs.length){alert('No data yet');return;}
    let csv='';
    runs.forEach((r,i)=>{
      csv+=`# run=${i+1}\n`;
      if(r.start) csv+=`# start=${r.start.toISOString()}\n`;
      if(r.end)   csv+=`# end=${r.end.toISOString()}\n`;
      csv+=`# volume_L=${r.volume}\n`;
      csv+=`# regulator_version=${r.regulator}\n`;
      csv+=`# supply_pressure=${r.pressure}\n`;
      csv+='time_s,pps_filtered\n';
      r.trace.x.forEach((x,i)=>csv+=`${x},${r.trace.y[i]}\n`);
      csv+='\n';
    });
    const url=URL.createObjectURL(new Blob([csv],{type:'text/csv'}));
    Object.assign(document.createElement('a'),{href:url,download:'flow_curves.csv'}).click();
    URL.revokeObjectURL(url);
  }
  function downloadPng(){
    Plotly.toImage(chartEl,{format:'png'}).then(url=>{
      Object.assign(document.createElement('a'),{href:url,download:'flow_chart.png'}).click();
    });
  }

  function addLogItem(run){
    const li=document.createElement('li');
    const duration=(run.elapsed??0).toFixed(1);
    const avgPps=(run.pps??(run.delta&&run.elapsed?run.delta/run.elapsed:0)).toFixed(1);
    li.textContent=`${run.start?.toLocaleString()} ‚Äî ${duration}s, ${avgPps} pps (${run.delta} pulses)`;
    logList.appendChild(li);
  }

  function newRun(){
    const hue=(runs.length*60)%360;
    const name=`Run ${runs.length+1}: ${regVerEl.value||'n/a'} ‚Äî ${pressureInputEl.value||'n/a'} MPa`;
    const trace={
      x:[],
      y:[],
      mode:'lines',
      line:{color:`hsl(${hue},70%,40%)`},
      name:name,
      hovertemplate:`${name}<br>%{y:.1f} pps at %{x:.1f}s<extra></extra>`
    };
    Plotly.addTraces(chartEl, trace);
    const idx = chartEl.data.length - 1;
    currentRun={traceIndex:idx,trace:trace,volume:VOLUME_L,regulator:regVerEl.value,pressure:pressureInputEl.value,start:null,end:null};
    runs.push(currentRun);
  }
function softReset(){
    pulseEl.textContent='0';
    timerEl.textContent='0.0 s';
    ppsEl.textContent='0';
    resultEl.textContent='';
    armed=running=false; startPending=false;
    lastPulse=0; lastTime=performance.now(); lastMillis=0;
    rawBuf.length=0; ppsBuf.length=0; filtPps=null; emaPps=null;
    if(currentRun && !currentRun.end) currentRun.end=new Date();
    currentRun=null;
  }
  function hardReset(){
    softReset();
    runs.length=0;
    Plotly.react(chartEl, [], {
      xaxis:{title:'time (s)', range:[0, WINDOW_SEC]},
      yaxis:{title:'pulses / s', rangemode:'tozero'},
      margin:{l:40,r:10,b:40,t:10}
    }, {responsive:true, displaylogo:false, scrollZoom:true});
    logList.innerHTML='';
    globalMax=0;
  }

  /* --- WebSocket to Python bridge --- */
  const ws=new WebSocket('ws://localhost:8765');
  ws.onopen =()=>statusEl.textContent='üü¢ WebSocket open';
  ws.onerror=()=>statusEl.textContent='üî¥ WebSocket error';

  ws.onmessage=e=>{
    const d=JSON.parse(e.data);
    const now=performance.now();

    /* 1Ô∏è‚É£ live frame ----------------------------------------------------- */
    if(d.type==='live'){
      const pulses=d.pulses;
      pulseEl.textContent=pulses;

      /* arm->running transition on first pulse */
      if(armed && !running && pulses!==lastPulse){
        if(startPending){
          newRun();
          currentRun.start=new Date();
          startPending=false;
        }
        running=true; t0=now; lastChange=now; filtPps=null;
      }

      /* raw instantaneous pps */
      const dt = lastMillis ? (d.millis - lastMillis)/1000 : 0;
      if(dt>0 && pulses!==lastPulse){
        const rawPps=(pulses-lastPulse)/dt;

        /* --- median then moving average ------------------------------- */
        rawBuf.push(rawPps);
        if(rawBuf.length>MEDIAN_WINDOW) rawBuf.shift();
        const mid=[...rawBuf].sort((a,b)=>a-b)[Math.floor(rawBuf.length/2)];

        ppsBuf.push(mid);
        if(ppsBuf.length>MA_WINDOW) ppsBuf.shift();
        const sum=ppsBuf.reduce((a,b)=>a+b,0);
        let avg=sum/ppsBuf.length;
        if(emaPps===null) emaPps=avg; else emaPps=EMA_ALPHA*avg+(1-EMA_ALPHA)*emaPps;
        filtPps=emaPps;

        /* plot --------------------------------------------------------- */

        ppsEl.textContent=filtPps.toFixed(1);

        if(running && currentRun && now>t0){
          const t=(now-t0)/1000;

          const trace=currentRun.trace;
          trace.x.push(t);
          trace.y.push(filtPps);
          if(t>globalMax){
            globalMax=t;
            Plotly.relayout(chartEl,{"xaxis.range":[0,Math.max(WINDOW_SEC,globalMax)]});
          }
          Plotly.extendTraces(chartEl,{x:[[t]],y:[[filtPps]]},[currentRun.traceIndex]);
        }
      }

      if(pulses!==lastPulse) lastChange=now;
      if(running) timerEl.textContent=`${((now-t0)/1000).toFixed(1)} s`;

      /* auto-stop after NO_FLOW_MS of zero-increment */
      if(autoStopEl.checked && running && now-lastChange>NO_FLOW_MS){
        ws.send('stop'); armed=running=false; startPending=false;
      }

      lastPulse=pulses; lastTime=now; lastMillis=d.millis;
    }

    /* 2Ô∏è‚É£ status messages ---------------------------------------------- */
    if(d.type==='status'){
      if(d.msg==='serial-open'){
        statusEl.textContent='üü¢ Serial link ready';
        startBtn.disabled=resetBtn.disabled=resetAllBtn.disabled=false;
        saveCsvBtn.disabled=savePngBtn.disabled=false;
      }
      if(d.msg==='counter-reset'){
        resultEl.textContent='Counter reset ‚úîÔ∏é';
      }
    }

    /* 3Ô∏è‚É£ acknowledgements --------------------------------------------- */
    if(d.type==='ack'){
        if(d.status==='started'){
          softReset();
          newRun();
          currentRun.start=new Date();
          armed=true; running=true; startPending=false;
          t0=lastChange=performance.now();
          startBtn.disabled=true; stopBtn.disabled=false;
        }
      if(d.status==='reset-sent'){resultEl.textContent='Reset request sent‚Ä¶';}
    }

    /* 4Ô∏è‚É£ calibration result ------------------------------------------- */
    if(d.type==='cal'){
      armed=running=false;
      startBtn.disabled=false; stopBtn.disabled=true;

      if(currentRun){
        Object.assign(currentRun,{end:new Date(),delta:d.delta,elapsed:d.elapsed,pps:d.pps});
        addLogItem(currentRun);
        currentRun=null;
      }
      startPending=false;

      timerEl.textContent=`${d.elapsed.toFixed(1)} s`;
      resultEl.innerHTML=`<strong>${d.pps}</strong> pps<br>
                          (Œî=${d.delta} pulses in ${d.elapsed}s)`;
    }
  };

  /* --- button handlers --- */
  startBtn.onclick =()=>{
    ws.send(JSON.stringify({
      cmd:'start',
      volume:VOLUME_L,
      pulses: targetCountsEl.value?Number(targetCountsEl.value):undefined,
      seconds: targetSecondsEl.value?Number(targetSecondsEl.value):undefined
    }));
  };
  stopBtn.onclick  =()=>{ws.send('stop');armed=running=false;startPending=false;};
  resetBtn.onclick =()=>{ws.send('reset');softReset();};
  resetAllBtn.onclick=()=>{ws.send('reset');hardReset();};
  saveCsvBtn.onclick=downloadCsv;
  savePngBtn.onclick=downloadPng;
})();
</script>

</body>
</html>
